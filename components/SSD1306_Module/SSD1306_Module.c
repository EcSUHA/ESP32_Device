/* #################################################################################################
 *
 *      Name: SSD1306 Module
 *  Function: This is used to drive an SSD1306 display.
 *            Module for use with SCDE (Smart Connected Device Engine) only !
 *
 *  ESP 8266EX & ESP32 SoC Activities ...
 *  HoME CoNTROL & Smart Connected Device Engine Activities ...
 *  Copyright by EcSUHA
 *
 *  Created by Maik Schulze, Sandfuhren 4, 38448 Wolfsburg, Germany for EcSUHA.de 
 *
 *  MSchulze780@GMAIL.COM
 *  EcSUHA - ECONOMIC SURVEILLANCE AND HOME AUTOMATION - WWW.EcSUHA.DE
 * #################################################################################################
 *
 *define mySSD1306 SSD1306 I2CM
 */



#include <ProjectConfig.h>
#include <esp8266.h>
#include <Platform.h>



// the Smart-Connected-Device-Engine structures & types ...
#include <SCDE_s.h>

// provides WebIf, need the structures & types ...
#include "WebIf_Module.h"

// this Module uses an 1st stage, need the structures & types ...
#include "ESP32_I2C_Master_Module_s.h"

// this Modules structures & types ...
#include "SSD1306_Module.h"
#include "font8x8_basic.h"



// -------------------------------------------------------------------------------------------------

// set default build verbose - if no external override
#ifndef SSD1306_Module_DBG  
#define SSD1306_Module_DBG  5	// 5 is default
#endif 

// -------------------------------------------------------------------------------------------------


#include <WebIf_EspFSStdFileTX.h>
#include <WebIf_EspFSAdvFileTX.h>

#include "HTools_cgi.h"
#include <ServAPCfg_tpl.h>
#include <CGI_Redirect.h>



// -------------------------------------------------------------------------------------------------



/*
 * Implemented Values for Keys
 */

// SSD1306_SET_SIG_OUT_EN -> 'SIG_OUT_EN' -> Disabled|Enabled
SelectAData SSD1306_DisEna[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"Disabled"},
  {1,"Enabled"}, 
  {0, NULL}
  };

// SSD1306_SET_IDLE_LV -> 'IDLE_LV' -> Low|High
SelectAData SSD1306_LoHi[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"Low"},
  {1,"High"}, 
  {0, NULL}
  };

// SSD1306_SET_BLOCK -> 'PWM_BLOCK'-> High_Speed|Low_Speed
SelectAData SSD1306_PWM_BLOCK[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"High_Speed"},
  {1,"Low_Speed"},
  {0, NULL}
  };

// SSD1306_SET_TICK_SOURCE -> 'TICK_SOURCE'-> REF|APB_SLOW
SelectAData SSD1306_TICK_SOURCE[] = {  //ID, Text MAX CGI LEN BEACHTEN!!!
  {0,"REF"},
  {1,"APB_SLOW"}, 
  {0, NULL}
  };



/**
 * For Type: SSD1306
 * Implemented-Args-Keys, for input (MAX 64!). //IAK!!
 * KEYs-Field-Set for Feature specific query. Will be generated by SCDEH_ParseStrToparsedKVInput()
 * parsed result is stored in SSD1306_parsedKVInput_t
 */
enum SSD1306_SET_IK {				// Bit #XX for debugging

  // S0 calculation configuration
    SSD1306_SET_ON		= 0			// Bit #00 'ON'  -> 
  , SSD1306_SET_OFF				// Bit #01 'OFF'  -> 

  , SSD1306_SET_MAX				// Bit #02 'MAX'  -> 
  , SSD1306_SET_MIN				// Bit #03 'MIN'  -> 

  , SSD1306_SET_VAL				// Bit #04 'VAL'  -> 
  , SSD1306_SET_DIM				// Bit #05 'DIM'  -> 

  , SSD1306_SET_NAME				// Bit #06 'NAME'  -> 
  , SSD1306_SET_CAPS				// Bit #07 'CAPS'  -> 

  // Block #01 PWM configuration
  , SSD1306_SET_GPIO				// Bit #08 'GPIO' -> 
  , SSD1306_SET_BLOCK				// Bit #09 'BLOCK' -> 
  , SSD1306_SET_CHANNEL				// Bit #10 'CHANNEL' -> 
  , SSD1306_SET_TIMER				// Bit #11 'TIMER' -> 

  , SSD1306_SET_DUTY				// Bit #12 'DUTY' ->
  , SSD1306_SET_HPOINT				// Bit #13 'HPOINT' ->
  , SSD1306_SET_SIG_OUT_EN				// Bit #14 'SIG_OUT_EN' ->
  , SSD1306_SET_IDLE_LV				// Bit #15 'IDLE_LV' ->

  , SSD1306_SET_RESOLUTION			// Bit #16 'RESOLUTION' -> 
  , SSD1306_SET_TICK_SOURCE			// Bit #17 'TICK_SOURCE' ->
  , SSD1306_SET_FREQ_HZ				// Bit #18 'FREQ_HZ' ->

  , SSD1306_SET_THR_L_LIM_EN			// Bit #19 'THR_L_LIM_EN' -> DIS/ENA
  , SSD1306_SET_THR_H_LIM_EN			// Bit #20 'THR_H_LIM_EN' -> DIS/ENA
  , SSD1306_SET_THR_ZERO_EN			// Bit #21 'THR_ZERO_EN' -> DIS/ENA
  , SSD1306_SET_FILTER_EN				// Bit #22 'FILTER_EN' -> DIS/ENA
  , SSD1306_SET_FILTER_THRES			// Bit #23 'FILTER_THRES' -> decval 10 bit zahl
  , SSD1306_SET_CNT_THRES1				// Bit #24 'CNT_THRES1' -> decval 16 bit zahl
  , SSD1306_SET_CNT_THRES0				// Bit #25 'CNT_THRES0' -> decval 16 bit zahl
  , SSD1306_SET_CNT_L_LIM				// Bit #26 'CNT_L_LIM' -> decval 10 bit zahl
  , SSD1306_SET_CNT_H_LIM				// Bit #27 'CNT_H_LIM' -> decval 10 bit zahl

// end marker
  , SSD1306_SET_IK_Number_of_keys			// Bit #27 MAX 64 IMPLEMENTED !

};

 

/**
 * For Type: SSD1306
 * Implemented readings (MAX 32!)
 * Can be assigned to Implemented Keys, if affected
 */
enum SSD1306_Readings {			// Bit #XX for debugging

   SSD1306_R_DUTY		= (1<<0)	// Bit #00 'Duty'  -> 

  ,SSD1306_R_RESOLUTION	= (1<<1)	// Bit #01 'Resolution' -> 

  ,SSD1306_R_NAME		= (1<<2)	// Bit #02 'name' + caps + ufid -> 

};



/**
 * For Type: SSD1306
 * Implemented KEYS and assigned readings for this query - analyzed by by http_parser_parse_url()

 * Num should meet enum XX_QueryFields
 * Result is stored in struct SCDE_XX_parsedKVInput
 */
kvParseImplementedKeys_t SSD1306_Set_ImplementedKeys[] = {
// |                                                          affected readings										              	|  CMD

// for usage 
   { SSD1306_R_DUTY | SSD1306_R_RESOLUTION															, "ON" }		// #00
  ,{ SSD1306_R_DUTY | SSD1306_R_RESOLUTION															, "OFF" }		// #01
  ,{ SSD1306_R_DUTY | SSD1306_R_RESOLUTION															, "MAX" }		// #02
  ,{ SSD1306_R_DUTY | SSD1306_R_RESOLUTION															, "MIN" }		// #03
  ,{ SSD1306_R_DUTY | SSD1306_R_RESOLUTION															, "VAL" }		// #04
  ,{ SSD1306_R_DUTY | SSD1306_R_RESOLUTION															, "DIM" }		// #05

  ,{ SSD1306_R_DUTY | SSD1306_R_RESOLUTION | SSD1306_R_NAME												, "NAME" }		// #06
  ,{ SSD1306_R_DUTY | SSD1306_R_RESOLUTION | SSD1306_R_NAME												, "CAPS" }		// #07

// for configuration
  ,{ 0																					, "GPIO" }		// #08
  ,{ 0																					, "BLOCK" }		// #09
  ,{ 0																					, "CHANNEL" }		// #10
  ,{ 0																					, "TIMER" }		// #11
  ,{ 0																					, "DUTY" }		// #12
  ,{ 0																					, "HPOINT" }		// #13
  ,{ 0																					, "SIG_OUT_EN" }	// #14
  ,{ 0																					, "IDLE_LV" }		// #15

  ,{ 0																					, "RESOLUTION" }		// #16
  ,{ 0																					, "TICK_SOURCE" }	// #17
  ,{ 0																					, "FREQ_HZ" }		// #18

  ,{ 0																					, "THR_L_LIM_EN" }	// #19
  ,{ 0																					, "THR_H_LIM_EN" }	// #20
  ,{ 0																					, "THR_ZERO_EN" }	// #21
  ,{ 0																					, "FILTER_EN" }		// #22
  ,{ 0																					, "FILTER_THRES" }	// #23
  ,{ 0																					, "CNT_THRES1" }	// #24
  ,{ 0																					, "CNT_THRES0" }	// #25
  ,{ 0																					, "CNT_L_LIM" }		// #26
  ,{ 0																					, "CNT_H_LIM" }		// #27

}; // number of elements should be equal with XX_SET_IK_Number_of_keys, LIMIT IS 64 ELEMENTS !



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: SSD1306_ActiveResourcesDataA_forWebIf
 *  Desc: Resource-Content-structure of active Directory - PART A (Resource-Data-Row)
 *  Data: WebIf_ActiveResourcesDataA_t[X] from HttpD.h
 * -------------------------------------------------------------------------------------------------
 */
// Content:   AllowedMethodBF          | AllowedDocMimeBF  | AllowedSchemeBF |free|CgiNo| EnaByBit | Url
const WebIf_ActiveResourcesDataA_t SSD1306_ActiveResourcesDataA_forWebIf[] = {  //ICACHE_RODATA_ATTR = 

  // SOC Hardware Cfg
  { 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  0, 0b00000000, "/SoCHWCfg"}

  // WiFi Stations Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  1, 0b00000000, "/WiFi/StationCfg"}

  // WIFI Q-Connect PAGES
 ,{ 0b00000000000000000000000000001010, 0b0000000000000010, 0b0000000000000001,  0,  2, 0b00000000, "/WiFi/QConnect"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000001000, 0b0000000000000001,  0,  3, 0b00000000, "/WiFi/WiFiScan"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000000100, 0b0000000000000001,  0,  4, 0b00000000, "/WiFi/Connect"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000000100, 0b0000000000000001,  0,  5, 0b00000000, "/WiFi/Setmode"}

  // Service Access Point Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  6, 0b00000000, "/WiFi/ServAPCfg"}

  // TimeStamp Cfg
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  7, 0b00000000, "/TiStCfg"}

  // Firmware Update
 ,{ 0b00000000000000000000000000001010, 0b0000000000001110, 0b0000000000000001,  0,  8, 0b00000000, "/Firmware"}

  // Redirects
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0,  9, 0b00000000, "/WiFi"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0,  9, 0b00000000, "/WiFi/"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000001, 0b0000000000000001,  0, 10, 0b00000000, "/"}	// nomime
 ,{ 0b00000000000000000000000000001010, 0b0000000000000010, 0b0000000000000001,  0, 10, 0b00000000, "/index"}	// .htm

  // Secret services
 ,{ 0b00000000000000000000000000001010, 0b0000000000100000, 0b0000000000000001,  0, 11, 0b00000000, "/32MBitFlash"}
 ,{ 0b00000000000000000000000000001010, 0b0000000000100000, 0b0000000000000001,  0, 12, 0b00000000, "/wfs"}

 ,{0,0,0,0,0,0,"*"}

  };



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: SSD1306_ActiveResourcesDataB_forWebIf
 *  Desc: Resource-Content-structure of active Directory - PART B (Procedure-Call-Data-Row) 
 *  Data: WebIf_ActiveResourcesDataB_t[X] from HttpD.h
 * -------------------------------------------------------------------------------------------------
 */
// CgiFucID=(No.<<16)+AllowedSchemeBF |      cgi            |     cgi_data
const WebIf_ActiveResourcesDataB_t SSD1306_ActiveResourcesDataB_forWebIf[] =  {  //ICACHE_RODATA_ATTR =

  // ### SOC Hardware Cfg ###
  {( 0<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	SoCHWCfg_tpl	}
 ,{( 0<<16) +	0b0000000000000100,	NULL,NULL}//	SoCHWCfg_cgi,		NULL		}
 ,{( 0<<16) +	0b0000000000001000,	NULL,NULL}//	SoCHWCfg_jso,		NULL		}

  // ### WiFi Station Cfg ###
 ,{( 1<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	StationCfg_tpl	}
 ,{( 1<<16) +	0b0000000000000100,	NULL,NULL}//	StationCfg_cgi,		NULL		}
 ,{( 1<<16) +	0b0000000000001000,	NULL,NULL}//	StationCfg_jso,		NULL		}

  // ### WIFI Q-Connect PAGES ###
 ,{( 2<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	WifiQConnect_tpl}
 ,{( 3<<16) +	0b0000000000001000,	NULL,NULL}//	WiFiScan_jso,		NULL		}
 ,{( 4<<16) +	0b0000000000000100,	NULL,NULL}//	WiFiConnect_cgi,	NULL		}
 ,{( 5<<16) +	0b0000000000000100,	NULL,NULL}//	WifiSetMode_cgi,	NULL		}	

  // ### Service Access Point Cfg ###
 ,{( 6<<16) +	0b0000000000000010,	WebIf_EspFSAdvFileTX,	ServAPCfg_tpl	}
 ,{( 6<<16) +	0b0000000000000100,	NULL,NULL}//	ServAPCfg_cgi,		NULL		}
 ,{( 6<<16) +	0b0000000000001000,	NULL,NULL}//	ServAPCfg_jso,		NULL		}

  // ### TimeStamp Cfg ###
 ,{( 7<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	TiStCfg_tpl	}
 ,{( 7<<16) +	0b0000000000000100,	NULL,NULL}//	TiStCfg_cgi,		NULL		}
 ,{( 7<<16) +	0b0000000000001000,	NULL,NULL}//	TiStCfg_jso,		NULL		}

  // ### Firmware Update ###
 ,{( 8<<16) +	0b0000000000000010,	NULL,NULL}//	EspFsTemplate_cgi,	FirmwareUd_tpl	}
 ,{( 8<<16) +	0b0000000000000100,	NULL,NULL}//	FirmwareUd_cgi,		NULL		}
 ,{( 8<<16) +	0b0000000000001000,	NULL,NULL}//	FirmwareUd_jso,		NULL		}

  // ### Redirects ###
 ,{( 9<<16) +	0b0000000000000001,	cgiRedirect,	"/WiFi/QConnect.htm"		}
 ,{(10<<16) +	0b0000000000000001,	cgiRedirect,	"/CoNTROL_8S-1C-1ADC.htm"	}
 ,{(10<<16) +	0b0000000000000010,	cgiRedirect,	"/CoNTROL_8S-1C-1ADC.htm"	}

  // ### Secret services ###
 ,{(11<<16) +	0b0000000000100000,	ReadFullFlash_cgi,	NULL		}		//.bin
 ,{(12<<16) +	0b0000000000100000,	NULL,NULL}//	WriteFileSystem_cgi,	NULL		}		//.bin

  };



/**
 * -------------------------------------------------------------------------------------------------
 *  DName: SSD1306_Module
 *  Desc: Data 'Provided By Module' for the SSD1306 module (functions + infos this module 
 *        provides to SCDE)
 *  Data: 
 * -------------------------------------------------------------------------------------------------
 */
ProvidedByModule_t SSD1306_ProvidedByModule = {   // A-Z order
  "SSD1306"				// Type-Name of module -> on Linux libfilename.so !
  ,7					// size of Type-Name

  ,NULL					// Add
  ,SSD1306_Attribute			// Attribute
  ,SSD1306_Define			// Define
  ,NULL					// Delete
  ,NULL					// DirectRead
  ,NULL					// DirectWrite
  ,NULL					// Except
  ,NULL					// Get
  ,SSD1306_IdleCb			// IdleCb
  ,SSD1306_Initialize			// Initialize
  ,NULL					// Notify
  ,NULL					// Parse
  ,NULL					// Read
  ,NULL					// Ready
  ,NULL					// Rename
  ,SSD1306_Set				// Set
  ,SSD1306_Shutdown			// Shutdown
  ,NULL					// State
  ,NULL					// Sub
  ,SSD1306_Undefine			// Undefine
  ,NULL					// Write
  ,NULL					// FnProvided
  ,sizeof(SSD1306_Definition_t)		// Modul specific Size (Common_Definition_t + X)
};



/* -------------------------------------------------------------------------------------------------
 *  FName: Attribute Fn
 *  Desc: Informs an 'definition' of this 'module' for 'attribute' activities (set/delete)
 *  Info: 'attr_cmmand' is the command for the activity: set, delete
 *        'attr_name' is the attribute name
 *        'attr_value' is the attribute value
 *  Para: Common_Definition_t* p_entry_definition -> the 'definition' identified for the activities
 *	  const String_t attr_command -> the attribute-command
 *	  const String_t attr_name -> the attribute-name
 *	  const String_t attr_value -> the attribute-value
 *  Rets: Entry_String_t* -> = SCDE_OK (no ret msg) or VETO (SLTQ Entry_String_t* with ret msg)
 * -------------------------------------------------------------------------------------------------
 */
Entry_String_t* ICACHE_FLASH_ATTR
SSD1306_Attribute(Common_Definition_t* p_entry_definition,
	 const String_t attr_command,
	 const String_t attr_name,
	 const String_t attr_value)
{
  // make common ptr to modul specific ptr
  SSD1306_Definition_t* p_entry_ssd1306_definition =
		  (SSD1306_Definition_t*) p_entry_definition;

  // to store the ret_msg. SCDE_OK = no msg 
  Entry_String_t* p_entry_ret_msg = SCDE_OK;

// -------------------------------------------------------------------------------------------------

  #if SSD1306_Module_DBG >= 5
  SCDEFn_at_SSD1306_M->Log3Fn(p_entry_ssd1306_definition->common.name,
	p_entry_ssd1306_definition->common.nameLen,
	5,
	"Attribute Fn (Module '%.*s') is called with args: "
	"attr_command '%.*s' attr_name '%.*s' attr_value '%.*s'",
	p_entry_ssd1306_definition->common.module->provided->typeNameLen,
	p_entry_ssd1306_definition->common.module->provided->typeName,attr_command.len,
	attr_command.p_char,
  	attr_name.len,
	attr_name.p_char,
	attr_value.len,
	attr_value.p_char);
  #endif

// ------------------------------------------------------------------------------------------------

  return p_entry_ret_msg;
}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: SSD1306_Define
 *  Desc: Finalizes the defines a new "device" of 'BH1750' type. Contains devicespecific init code.
 *  Info: 
 *  Para: Common_Definition_t *Common_Definition -> prefilled ESP32Control Definition
 *        char *Definition -> the last part of the CommandDefine arg* 
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t*
SSD1306_Define(Common_Definition_t *Common_Definition)
{
  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  SSD1306_Definition_t* SSD1306_Definition =
		  (SSD1306_Definition_t*) Common_Definition;

// -------------------------------------------------------------------------------------------------

  #if SSD1306_Module_DBG >= 5
  SCDEFn_at_SSD1306_M->Log3Fn(Common_Definition->name
	,Common_Definition->nameLen
	,5
	,"DefineFn of Module '%.*s' is called to continue creation of Definition '%.*s' with args '%.*s'."
	,SSD1306_Definition->common.module->provided->typeNameLen
	,SSD1306_Definition->common.module->provided->typeName
	,SSD1306_Definition->common.nameLen
	,SSD1306_Definition->common.name
	,SSD1306_Definition->common.definitionLen
	,SSD1306_Definition->common.definition);
  #endif

// ------------------------------------------------------------------------------------------------

  // new conversation
  uint8_t *defArgsText = Common_Definition->definition;
  size_t defArgsTextLen = Common_Definition->definitionLen;

  // Check for args. This type requires args...
  if (!defArgsTextLen) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Expected Args!");

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // store FD to Definition. Will than be processed in global loop ... -> THIS MODULE USES NO FD
  SSD1306_Definition->common.fd = -1;

// ------------------------------------------------------------------------------------------------

  // init WebIf_Provided offset
//  ESP32Control_Definition->common.link =
//	&ESP32Control_Definition->WebIf_Provided;

  // check for loaded Module 'WebIf' -> get provided Fn
  SSD1306_Definition->WebIf_Provided.WebIf_FnProvided =
	NULL;//(WebIf_FnProvided_t *) SCDEFn_at_SSD1306_M->GetFnProvidedByModule("WebIf");

 // Providing data for WebIf? Initialise data provided for WebIf
  if (SSD1306_Definition->WebIf_Provided.WebIf_FnProvided) {

	SSD1306_Definition->WebIf_Provided.ActiveResourcesDataA =
		(WebIf_ActiveResourcesDataA_t *) &SSD1306_ActiveResourcesDataA_forWebIf;

	SSD1306_Definition->WebIf_Provided.ActiveResourcesDataB =
		(WebIf_ActiveResourcesDataB_t *) &SSD1306_ActiveResourcesDataB_forWebIf;

	}

  else	{

	SCDEFn_at_SSD1306_M->Log3Fn(Common_Definition->name
		,Common_Definition->nameLen
		,1
		,"Could not enable WebIf support for '%.*s'. Type '%.*s' detects Type 'WebIf' is NOT loaded!"
		,SSD1306_Definition->common.nameLen
		,SSD1306_Definition->common.name
		,SSD1306_Definition->common.module->provided->typeNameLen
		,SSD1306_Definition->common.module->provided->typeName);
	}

// ------------------------------------------------------------------------------------------------

  // Parse define-args (KEY=VALUE) protocol -> gets parsedKVInput in allocated mem, NULL = ERROR
  parsedKVInputArgs_t *parsedKVInput = 
	SCDEFn_at_SSD1306_M->ParseKVInputArgsFn(SSD1306_SET_IK_Number_of_keys	// Num Implementated KEYs MAX
	,SSD1306_Set_ImplementedKeys				// Implementated Keys
	,defArgsText							// our args text
	,defArgsTextLen);						// our args text len

  // parsing may report an problem. args contain: unknown keys, double keys, ...?
  if (!parsedKVInput) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Args '%.*s' not taken! Check the KEYs!"
		,defArgsTextLen
		,defArgsText);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------






// ------------------------------------------------------------------------------------------------

  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = ( (1 << SSD1306_SET_GPIO)
			        | (1 << SSD1306_SET_BLOCK)
			        | (1 << SSD1306_SET_CHANNEL)
			        | (1 << SSD1306_SET_TIMER)
			        | (1 << SSD1306_SET_DUTY)
			        | (1 << SSD1306_SET_HPOINT)
			        | (1 << SSD1306_SET_SIG_OUT_EN)
			        | (1 << SSD1306_SET_IDLE_LV)
			        | (1 << SSD1306_SET_RESOLUTION)
			        | (1 << SSD1306_SET_TICK_SOURCE)
			        | (1 << SSD1306_SET_FREQ_HZ) );

  // set forbidden Keys -> Keys that are not allowed in this request
  parsedKVInput->forbiddenKVBF = 0;
/*
  // process the set-args (key=value@) protocol
  if (SSD1306_ProcessKVInputArgs(SSD1306_Definition
	,parsedKVInput				// KVInput parsed
	,defArgsText				// our args text
	,defArgsTextLen) ) {			// our args text len

	// Processing reports an problem. Args not taken. Response with error text.

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Processing Error! Args '%.*s' not taken! Check the VALUEs!"
		,defArgsTextLen
		,defArgsText);

	// free allocated memory for query result key-field
	free(parsedKVInput);

	return retMsg;

  }
*/
// ------------------------------------------------------------------------------------------------

  // set affected readings
 // SSD1306_SetAffectedReadings(SSD1306_Definition
//	,parsedKVInput->affectedReadingsBF);

// ------------------------------------------------------------------------------------------------

  // free allocated memory for query result key-field
  free(parsedKVInput);

// ------------------------------------------------------------------------------------------------
//play here

  // temp build 'ESP32_I2C_Master'
	SSD1306_Definition->stage1definitionNameLen = 
		asprintf(&SSD1306_Definition->stage1definitionName,"I2CM");
/*
  // get definition of 1st stage definition we want to use for tx/rx
  ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition_Stage1;

  ESP32_I2C_Master_Definition_Stage1 = SCDEFn_at_SSD1306_M->GetDefinitionPtrByNameFn(
		 SSD1306_Definition->stage1definitionNameLen
		,SSD1306_Definition->stage1definitionName);
*/

  // make common ptr to modul specific ptr
  ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition =
		  (ESP32_I2C_Master_Definition_t*) SCDEFn_at_SSD1306_M->GetDefinitionPtrByNameFn(
		 SSD1306_Definition->stage1definitionNameLen
		,SSD1306_Definition->stage1definitionName);


  if (ESP32_I2C_Master_Definition) {

	SCDEFn_at_SSD1306_M->Log3Fn(Common_Definition->name
		,Common_Definition->nameLen
		,1
		,"Found first Stage with name '%.*s'. Type '%.*s' !"
		,ESP32_I2C_Master_Definition->common.nameLen
		,ESP32_I2C_Master_Definition->common.name
		,ESP32_I2C_Master_Definition->common.module->provided->typeNameLen
		,ESP32_I2C_Master_Definition->common.module->provided->typeName);

	// store table of function callbacks provided & made accessible from stage 1 Module
	ESP32_I2C_Master_Fn_t* ESP32_I2C_Master_Fn =
		ESP32_I2C_Master_Definition->ESP32_I2C_Master_Fn;









// Following definitions are bollowed from 
// http://robotcantalk.blogspot.com/2015/03/interfacing-arduino-with-ssd1306-driven.html

// SLA (0x3C) + WRITE_MODE (0x00) =  0x78 (0b01111000)
#define OLED_I2C_ADDRESS   0x3C

// Control byte
#define OLED_CONTROL_BYTE_CMD_SINGLE    0x80
#define OLED_CONTROL_BYTE_CMD_STREAM    0x00
#define OLED_CONTROL_BYTE_DATA_STREAM   0x40

// Fundamental commands (pg.28)
#define OLED_CMD_SET_CONTRAST           0x81    // follow with 0x7F
#define OLED_CMD_DISPLAY_RAM            0xA4
#define OLED_CMD_DISPLAY_ALLON          0xA5
#define OLED_CMD_DISPLAY_NORMAL         0xA6
#define OLED_CMD_DISPLAY_INVERTED       0xA7
#define OLED_CMD_DISPLAY_OFF            0xAE
#define OLED_CMD_DISPLAY_ON             0xAF

// Addressing Command Table (pg.30)
#define OLED_CMD_SET_MEMORY_ADDR_MODE   0x20    // follow with 0x00 = HORZ mode = Behave like a KS108 graphic LCD
#define OLED_CMD_SET_COLUMN_RANGE       0x21    // can be used only in HORZ/VERT mode - follow with 0x00 and 0x7F = COL127
#define OLED_CMD_SET_PAGE_RANGE         0x22    // can be used only in HORZ/VERT mode - follow with 0x00 and 0x07 = PAGE7

// Hardware Config (pg.31)
#define OLED_CMD_SET_DISPLAY_START_LINE 0x40
#define OLED_CMD_SET_SEGMENT_REMAP      0xA1    
#define OLED_CMD_SET_MUX_RATIO          0xA8    // follow with 0x3F = 64 MUX
#define OLED_CMD_SET_COM_SCAN_MODE      0xC8    
#define OLED_CMD_SET_DISPLAY_OFFSET     0xD3    // follow with 0x00
#define OLED_CMD_SET_COM_PIN_MAP        0xDA    // follow with 0x12
#define OLED_CMD_NOP                    0xE3    // NOP

// Timing and Driving Scheme (pg.32)
#define OLED_CMD_SET_DISPLAY_CLK_DIV    0xD5    // follow with 0x80
#define OLED_CMD_SET_PRECHARGE          0xD9    // follow with 0xF1
#define OLED_CMD_SET_VCOMH_DESELCT      0xDB    // follow with 0x30

// Charge Pump (pg.62)
#define OLED_CMD_SET_CHARGE_PUMP        0x8D    // follow with 0x14





   vTaskDelay(200 / portTICK_RATE_MS);




	esp_err_t espRc;

	//oled demo: init
	i2c_cmd_handle_t cmd = ESP32_I2C_Master_Fn->i2c_cmd_link_createFn();

	ESP32_I2C_Master_Fn->i2c_master_startFn(cmd);

	ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd,
		(OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

	ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd,
		OLED_CONTROL_BYTE_CMD_STREAM, true);

	ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd,
		OLED_CMD_SET_CHARGE_PUMP, true);

	ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd,
		0x14, true);

	// reverse left-right mapping
	ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd,
		OLED_CMD_SET_SEGMENT_REMAP, true);

	// reverse up-bottom mapping
	ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd,
		OLED_CMD_SET_COM_SCAN_MODE, true);

	ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd,
		OLED_CMD_DISPLAY_ON, true);

	ESP32_I2C_Master_Fn->i2c_master_stopFn(cmd);

  String_t datax;
  datax.p_char = (uint8_t*) cmd;
  datax.len = 8; //???

	retMsg = ESP32_I2C_Master_Definition->common.module->provided->
			WriteFn(ESP32_I2C_Master_Definition, datax);	//10 / portTICK_PERIOD_MS

	if (retMsg) {

       		// error occured - no further processing - return retMsg;

	} else {

	// display pattern
	i2c_cmd_handle_t cmd;

	for (uint8_t i = 0; i < 8; i++) {
		cmd = ESP32_I2C_Master_Fn->i2c_cmd_link_createFn();
		ESP32_I2C_Master_Fn->i2c_master_startFn(cmd);
		ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);
		ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, OLED_CONTROL_BYTE_CMD_SINGLE, true);
		ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, 0xB0 | i, true);
		ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);

		for (uint8_t j = 0; j < 128; j++) {
			ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, 0xFF >> (j % 8), true);
		}

		ESP32_I2C_Master_Fn->i2c_master_stopFn(cmd);

/*
		i2c_master_cmd_begin(ESP32_I2C_Master_Definition->i2c_obj,
			cmd,
			10 / portTICK_PERIOD_MS);

		i2c_cmd_link_delete(cmd);
*/

		datax.p_char = (uint8_t*) cmd;
		datax.len = 8; //???

		retMsg = ESP32_I2C_Master_Definition->common.module->provided->WriteFn(ESP32_I2C_Master_Definition, datax);

		if (retMsg) break;
	}

  }	





  }

  vTaskDelay(200 / portTICK_RATE_MS);

// ------------------------------------------------------------------------------------------------

  // set up 1st idle Callback
  SSD1306_Definition->common.Common_CtrlRegA |= F_WANTS_IDLE_TASK;

  return retMsg;

// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
/*
// alternative end in case of errors - free/destroy all allocated things and return SCDE_FAIL.
  err:

  if (parsedKVInput) {

    free(parsedKVInput);

  }

  return retMsg;
*/
}



/*
 * ------------------------------------------------------------------------------------------------
 *  FName: SSD1306_IdleCb	
 *  Desc: Timed callback, X Hz, to do type dependend processing tasks.
 *  Info: 
 *  Para: Common_Definition_t *Common_Definition -> prefilled WebIf Definition 
 *  Rets: ? unclear char* -> response text NULL=no text
 * ------------------------------------------------------------------------------------------------
 */
int
SSD1306_IdleCb(Common_Definition_t *Common_Definition)
{
  // prepare STAILQ head for multiple RetMsg storage
  struct headRetMsgMultiple_s headRetMsgMultiple;

  // Initialize the queue
  STAILQ_INIT(&headRetMsgMultiple);

  // make common ptr to modul specific ptr
  SSD1306_Definition_t *SSD1306_Definition =
		  (SSD1306_Definition_t*) Common_Definition;

// -------------------------------------------------------------------------------------------------
/*
  #if SSD1306_Module_DBG >= 7
  SCDEFn_at_SSD1306_M->Log3Fn(Common_Definition->name
	,Common_Definition->nameLen
	,7
	,"IdleCb called. (Module '%.*s')"
	,SSD1306_Definition->common.module->provided->typeNameLen
	,SSD1306_Definition->common.module->provided->typeName);
  #endif
*/
// ------------------------------------------------------------------------------------------------

  // get assigned Stage 1 Modul
  ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition =
		  (ESP32_I2C_Master_Definition_t*) SCDEFn_at_SSD1306_M->GetDefinitionPtrByNameFn(
		 SSD1306_Definition->stage1definitionNameLen
		,SSD1306_Definition->stage1definitionName);
  // we got it?
  if (ESP32_I2C_Master_Definition) {



  // goal: loop the readings on display
  int cnt = 0;

  // need: module, definition, reading
  Module_t *currentModule;
  Common_Definition_t *currentCommon_Definition;
  xReadingSLTQE_t *currentReadingSLTQE = NULL;

//  // loop through currently stored modules
//  STAILQ_FOREACH(currentModule, &SCDERoot->HeadModules, entries) {

	// loop through currently stored definitions
	STAILQ_FOREACH(currentCommon_Definition, &SCDERoot_at_SSD1306_M->HeadCommon_Definitions, entries) {

		// loop through currently stored readings
		STAILQ_FOREACH(currentReadingSLTQE, &currentCommon_Definition->headReadings, entries) {

			// not the reading nr. we are searching for ?
			if ( cnt != SSD1306_Definition->readingOnDisplay ) {

				// next reading no.
				cnt++;
	
				continue;
			}

			// yes its the one. next time next reading
			else {

				SSD1306_Definition->readingOnDisplay++;

				 // we have a reading ?
  				if (currentReadingSLTQE) {

					// get tist text
					strText_t strText =
						SCDEFn_at_SSD1306_M->FmtDateTimeFn(currentReadingSLTQE->readingTist);

					SCDEFn_at_SSD1306_M->Log3Fn(Common_Definition->name
						,Common_Definition->nameLen
						,7
						,"Now Reading:  %.*s | %.*s = %.*s"
						,strText.strTextLen
						,strText.strText
						,currentReadingSLTQE->nameString.len
						,currentReadingSLTQE->nameString.p_char
						,currentReadingSLTQE->valueString.len
						,currentReadingSLTQE->valueString.p_char);



	task_ssd1306_display_text(ESP32_I2C_Master_Definition, 
		currentReadingSLTQE->nameString.p_char,
		currentReadingSLTQE->nameString.len);


					free(strText.strText);

					// next
					SSD1306_Definition->readingOnDisplay++;

					goto ReadingFound;
 				 }
			}	
		}
	}
 // }






	  // no reading !

	SCDEFn_at_SSD1306_M->Log3Fn(Common_Definition->name
		,Common_Definition->nameLen
		,7
		,"No readings found!");

	// restart
	SSD1306_Definition->readingOnDisplay = 0;
  

  

 
  }

ReadingFound:














/*
  // get definition of 1st stage definition we want to use for tx/rx
  ESP32_I2C_Master_Definition_t *ESP32_I2C_Master_Definition_Stage1;

  ESP32_I2C_Master_Definition_Stage1 = SCDEFn_at_SSD1306_M->GetDefinitionPtrByNameFn(
		 SSD1306_Definition->stage1definitionNameLen
		,SSD1306_Definition->stage1definitionName);

  // prepare further specific Stage exchange data
  ESP32_I2C_Master_StageXCHG_t *ESP32_I2C_Master_StageXCHG = NULL;

  // call stage 1, if found
  if (ESP32_I2C_Master_Definition_Stage1) {
*/


/*
	// and 
	if (Common_Definition->module->provided->DirectWriteFn) {

		// call modules DirectWriteFn, if retMsg != NULL -> interpret as veto
		strTextMultiple_t *retMsg =  
			Common_Definition->module->provided->DirectWriteFn(
			 ESP32_I2C_Master_Definition_Stage1
			,SSD1306_Definition
			,ESP32_I2C_Master_StageXCHG);

		// got an error msg?
		if (retMsg) {

			// insert retMsg in stail-queue
			STAILQ_INSERT_TAIL(&headRetMsgMultiple, retMsg, entries);
		}
	}
*/
/*
  }

  // stage 1 not found, log note
  else {

  }
*/
// -------------------------------------------------------------------------------------------------



// -------------------------------------------------------------------------------------------

/* Description of state machine for BH1750 data query (light intensity)
 *
 * State0: initial delay
 *
 * State1: set mode
 * _________________________________________________________________
 * | start | slave_addr + wr_bit + ack | write 1 byte + ack  | stop |
 * --------|---------------------------|---------------------|------|
 *
 * State2: wait more than 24 ms
 *
 * State3: read sensor data
 * ______________________________________________________________________________________
 * | start | slave_addr + rd_bit + ack | read 1 byte + ack  | read 1 byte + nack | stop |
 * --------|---------------------------|--------------------|--------------------|------|
 *
 * State4: wait ?
 *
 * State5: goto step 3?
 *
 */



#define BH1750_SENSOR_ADDR  0x23	// slave address for BH1750 sensor
#define BH1750_CMD_START    0x23	// Command to set measure mode
#define WRITE_BIT  I2C_MASTER_WRITE	// I2C master write
#define READ_BIT   I2C_MASTER_READ	// I2C master read
#define ACK_CHECK_EN   0x1		// I2C master will check ack from slave
#define ACK_CHECK_DIS  0x0		// I2C master will not check ack from slave
#define ACK_VAL    0x0			// I2C ack value
#define NACK_VAL   0x1			// I2C nack value

/*
  // storage for our I2C command queue
  i2c_cmd_handle_t cmd;

  esp_err_t ret;

//  enum SSD1306_QueryStates SSD1306_Definition->BH1750_QueryState;
//  enum state p_state = (enum state) conn->parser_state;

  enum SSD1306_QueryStates p_state = 
       (enum SSD1306_QueryStates) SSD1306_Definition->BH1750_QueryState;

  // enter the state machine for sensor data query
  switch (p_state) {// its SSD1306_Definition->BH1750_QueryState) {

	case s_ESP32_INTIAL_DELAY:		// #00

		state = s_SSD1306_SET_MODE;
		break;


	// JOB: create + execute set BH1750 mode command
	case s_SSD1306_SET_MODE: 		// #01

		cmd = i2c_cmd_link_create();

		i2c_master_start(cmd);

		i2c_master_write_byte(cmd, BH1750_SENSOR_ADDR << 1 | WRITE_BIT, ACK_CHECK_EN);

		i2c_master_write_byte(cmd, BH1750_CMD_START, ACK_CHECK_EN);

		i2c_master_stop(cmd);

		// send job to our IO-Device TX
//		int ret = callIoDev (cmd);

		state = s_SSD1306_SET_MODE_EXEC;
		break;


	// JOB: wait till set mode is finnished
	//      - set a delay
	case s_SSD1306_SET_MODE_EXEC: 	// #02

		i2c_cmd_link_delete(cmd);

	// we have a result / OK
        if (ret == ESP_OK) {

		#if SSD1306_Module_DBG >= 5
 		printf("|Set Mode OK>");
		#endif
	}

	// we have no result / error
	else {

		#if SSD1306_Module_DBG >= 5
		printf("|No ack, sensor not connected...skip...>");
		#endif 

 //		go to state 0 here return ESP_FAIL;
        }

     break;

     case s_SSD1306_WAIT_24MS:	// #02
     break;

     case s_SSD1306_READ_DATA:	// #03

        cmd = i2c_cmd_link_create();

        i2c_master_start(cmd);

        i2c_master_write_byte(cmd, BH1750_SENSOR_ADDR << 1 | READ_BIT, ACK_CHECK_EN);

        i2c_master_read_byte(cmd, &SSD1306_Definition->sensor_data_h, ACK_VAL);

        i2c_master_read_byte(cmd, &SSD1306_Definition->sensor_data_l, NACK_VAL);

        i2c_master_stop(cmd);

        // call our IO-Device TX
//        int ret = callIoDev (cmd);
i2c_cmd_link_delete(cmd);

	// we have a result
        if (ret == ESP_OK) {

           #if SSD1306_Module_DBG >= 5
           printf("|data_h: %02x, data_l: %02x, sensor val: %f>"
              ,SSD1306_Definition->sensor_data_h
              ,SSD1306_Definition->sensor_data_l
              ,(SSD1306_Definition->sensor_data_h << 8 | SSD1306_Definition->sensor_data_l ) / 1.2);
           #endif
        }

        // we have no result / error
        else {

           #if SSD1306_Module_DBG >= 5
           printf("|No ack, sensor not connected...skip...>");
           #endif

        }

 //       state = 3;

     break;

}
*/

/*
    case 3:
      Ampel1( ROT );
      Ampel2( ROT );
      state = 4;
      break;

    case 4:
      Ampel1( ROT_GELB );
      Ampel2( ROT );
      state = 5;
      break;

    case 5:
      Ampel1( GRUEN );
      Ampel2( ROT );
      state = 6;
      break;

    case 6:
      Ampel1( GELB );
      Ampel2( ROT );
      state = 7;
      break;

    case 7:
      Ampel1( ROT );
      Ampel2( ROT );
      state = 8;
      break;

    case 8:
      Ampel1( ROT );
      Ampel2( ROT_GELB );
      state = 1;
      break;
  }
}

















esp_err_t i2c_master_sensor_test(i2c_port_t i2c_num, uint8_t* data_h, uint8_t* data_l)
{

  i2c_cmd_handle_t cmd;

 state 1:
  cmd = i2c_cmd_link_create();
  i2c_master_start(cmd);
  i2c_master_write_byte(cmd, BH1750_SENSOR_ADDR << 1 | WRITE_BIT, ACK_CHECK_EN);
  i2c_master_write_byte(cmd, BH1750_CMD_START, ACK_CHECK_EN);
  i2c_master_stop(cmd);

  // call our IO-Device TX
  int ret = callIoDev (cmd);

  if (ret == ESP_FAIL) {
	printf("No ack, sensor not connected...skip...\n");
        go to state 0 here return ESP_FAIL;
    }



 state 3:

  cmd = i2c_cmd_link_create();
  i2c_master_start(cmd);
  i2c_master_write_byte(cmd, BH1750_SENSOR_ADDR << 1 | READ_BIT, ACK_CHECK_EN);
  i2c_master_read_byte(cmd, &SSD1306_Definition->data_h, ACK_VAL);
  i2c_master_read_byte(cmd, &SSD1306_Definition->data_l, NACK_VAL);
  i2c_master_stop(cmd);

  // call our IO-Device TX
  int ret = callIoDev (cmd);

  if (ret == ESP_OK) {
	printf("data_h: %02x\n", SSD1306_Definition->sensor_data_h);
	printf("data_l: %02x\n", SSD1306_Definition->sensor_data_l);
	printf("sensor val: %f\n",
		( SSD1306_Definition->sensor_data_h << 8 | SSD1306_Definition->sensor_data_l ) / 1.2);
  }

  else {
	printf("No ack, sensor not connected...skip...\n");
  }

*/





/* test code to write esp-i2c-slave
 *
 * 1. set mode
 * _________________________________________________________________
 * | start | slave_addr + wr_bit + ack | write 1 byte + ack  | stop |
 * --------|---------------------------|---------------------|------|
 * 2. wait more than 24 ms
 * 3. read data
 * ______________________________________________________________________________________
 * | start | slave_addr + rd_bit + ack | read 1 byte + ack  | read 1 byte + nack | stop |
 * --------|---------------------------|--------------------|--------------------|------|
 */
/*
esp_err_t i2c_master_sensor_test(i2c_port_t i2c_num, uint8_t* data_h, uint8_t* data_l)
{
    i2c_cmd_handle_t cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, BH1750_SENSOR_ADDR << 1 | WRITE_BIT, ACK_CHECK_EN);
    i2c_master_write_byte(cmd, BH1750_CMD_START, ACK_CHECK_EN);
    i2c_master_stop(cmd);


  // part in I.O. Device
    int ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(cmd);
    if (ret == ESP_FAIL) {
        return ret;
    }


    vTaskDelay(30 / portTICK_RATE_MS);

    cmd = i2c_cmd_link_create();
    i2c_master_start(cmd);
    i2c_master_write_byte(cmd, BH1750_SENSOR_ADDR << 1 | READ_BIT, ACK_CHECK_EN);
    i2c_master_read_byte(cmd, data_h, ACK_VAL);
    i2c_master_read_byte(cmd, data_l, NACK_VAL);
    i2c_master_stop(cmd);
    ret = i2c_master_cmd_begin(i2c_num, cmd, 1000 / portTICK_RATE_MS);
    i2c_cmd_link_delete(cmd);
    if (ret == ESP_FAIL) {
        return ESP_FAIL;
    }
    return ESP_OK;
}

*/






























  // set up next idle Callback
  SSD1306_Definition->common.Common_CtrlRegA |= F_WANTS_IDLE_TASK;

  return 0; //headRetMsgMultiple;
}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: SSD1306_Initialize
 *  Desc: Initializion of SCDE Function Callbacks of an new loaded module
 *  Info: Stores Module-Information (Function Callbacks) to SCDE-Root
 *  Para: SCDERoot_t* SCDERootptr -> ptr to SCDE Data Root
 *  Rets: ? unused
 *--------------------------------------------------------------------------------------------------
 */
int 
SSD1306_Initialize(SCDERoot_t* SCDERootptr)
{

  // make data root locally available
  SCDERoot_at_SSD1306_M = SCDERootptr;

  // make locally available from data-root: SCDEFn (Functions / callbacks) for faster operation
  SCDEFn_at_SSD1306_M = SCDERootptr->SCDEFn;

  SCDEFn_at_SSD1306_M->Log3Fn(SSD1306_ProvidedByModule.typeName
		  ,SSD1306_ProvidedByModule.typeNameLen
		  ,3
		  ,"InitializeFn called. Type '%.*s' now useable.\n"
		  ,SSD1306_ProvidedByModule.typeNameLen
		  ,SSD1306_ProvidedByModule.typeName);

  return 0;

}



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: SSD1306_Set
 *  Desc: Processes the device-specific command line arguments from the set command
 *  Info: Invoked by cmd-line 'Set ESP32Control_Definition.common.Name setArgs'
 *  Para: ESP32Control_Definition_t *ESP32Control_Definition -> WebIF Definition that should get a set cmd
 *        uint8_t *setArgsText -> the setArgsText
 *        size_t setArgsTextLen -> length of the setArgsText
 *  Rets: strTextMultiple_t* -> response text in allocated memory, NULL=no text
 * -------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
SSD1306_Set(Common_Definition_t* Common_Definition
	,uint8_t *setArgsText
	,size_t setArgsTextLen)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  SSD1306_Definition_t* SSD1306_Definition =
	(SSD1306_Definition_t*) Common_Definition;

  #if SSD1306_Module_DBG >= 5
  printf("\n|SSD1306_Set, Name:%.*s, got args:%.*s>"
	,SSD1306_Definition->common.nameLen
	,SSD1306_Definition->common.name
	,setArgsTextLen
	,setArgsText);
  #endif

// ------------------------------------------------------------------------------------------------

  // note: _Set Fn call not allowed with setArgsTextLen = 0 (CHECK!)

  // setArgsText '?' -> respond with help
  if ( (setArgsTextLen > 0) && (*setArgsText == '?') ) {

	// set start of possible Type-Name
	const uint8_t *tempTxt = setArgsText + 1;

	// a seek-counter
	int i = 1;

	// skip spaces after '?' (search for more ...)
	while( (i < setArgsTextLen) && (*tempTxt == ' ') ) {i++;tempTxt++;}

	// only spaces after '?' -> answer with Set-Capabilities
	if (i == setArgsTextLen) {

		// response with error text
		// alloc mem for retMsg
		retMsg = malloc(sizeof(strTextMultiple_t));

		// response with error text
		retMsg->strTextLen = asprintf(&retMsg->strText
			,"requested ? '%.*s' !"
			,setArgsTextLen
			,setArgsText);

		return retMsg;

		}
	// '? + X' here !!! -> normal parse
	}

// ------------------------------------------------------------------------------------------------

  // Parse set-args (KEY=VALUE) protocol -> gets parsedKVInput in allocated mem, NULL = ERROR
  parsedKVInputArgs_t *parsedKVInput = 
	SCDEFn_at_SSD1306_M->ParseKVInputArgsFn(SSD1306_SET_IK_Number_of_keys	// Num Implementated KEYs MAX for Set Fn
	,SSD1306_Set_ImplementedKeys		// Implementated Keys for Set Fn
	,setArgsText				// our args text
	,setArgsTextLen);			// our args text len

  // parsing may report an problem. args contain: unknown keys, double keys, ...?
  if (!parsedKVInput) {

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Parsing Error! Args '%.*s' not taken! Check the KEYs!"
		,setArgsTextLen
		,setArgsText);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // set required Keys -> Keys that should be there in this request
  parsedKVInput->requiredKVBF = 0;

  // set forbidden Keys -> Keys that are not allowed in this request
//  parsedKVInput->forbiddenKVBF = ( (1 << SSD1306_SET_CNT_UNIT) );
  parsedKVInput->forbiddenKVBF = 0;

  // process the set-args (key=value@) protocol
  if (SSD1306_ProcessKVInputArgs(SSD1306_Definition
	,parsedKVInput				// KVInput parsed
	,setArgsText				// our args text
	,setArgsTextLen) ) {			// our args text len

 	// Processing reports an problem. Args not taken. Response with error text.

	// alloc mem for retMsg
	retMsg = malloc(sizeof(strTextMultiple_t));

	// response with error text
	retMsg->strTextLen = asprintf(&retMsg->strText
		,"Processing Error! Args '%.*s' not taken! Check the VALUEs!"
		,setArgsTextLen
		,setArgsText);

	// free allocated memory for query result key-field
	free(parsedKVInput);

	return retMsg;
  }

// ------------------------------------------------------------------------------------------------

  // set affected readings
  SSD1306_SetAffectedReadings(SSD1306_Definition
	,parsedKVInput->affectedReadingsBF);

// ---------------------

  // free allocated memory for query result key-field
  free(parsedKVInput);

  return retMsg;

}



/**
 * --------------------------------------------------------------------------------------------------
 *  FName: SSD1306_Shutdown
 *  Desc: called after 
 *  Info: Invoked by cmd-line 'Undefine SSD1306_Definition.common.Name'
 *  Para: SSD1306_Definition_t *SSD1306_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * --------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
SSD1306_Shutdown(Common_Definition_t *Common_Definition)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  SSD1306_Definition_t* SSD1306_Definition =
	(SSD1306_Definition_t*) Common_Definition;

// -------------------------------------------------------------------------------------------------

  #if SSD1306_Module_DBG >= 5
  printf("\n|SSD1306_Shutdown, Name:%.*s>"
	,SSD1306_Definition->common.nameLen
	,SSD1306_Definition->common.name);
  #endif

// -------------------------------------------------------------------------------------------------

  return retMsg;

}



/**
 * --------------------------------------------------------------------------------------------------
 *  FName: SSD1306_Undefine
 *  Desc: Removes the define of an "device" of 'WebIF' type. Contains devicespecific init code.
 *  Info: Invoked by cmd-line 'Undefine ESP32Control_Definition.common.Name'
 *  Para: ESP32Control_Definition_t *ESP32Control_Definition -> WebIF Definition that should be removed
 *  Rets: strTextMultiple_t* -> response text NULL=no text
 * --------------------------------------------------------------------------------------------------
 */
strTextMultiple_t* ICACHE_FLASH_ATTR
SSD1306_Undefine(Common_Definition_t *Common_Definition)
{

  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

  // make common ptr to modul specific ptr
  SSD1306_Definition_t* SSD1306_Definition =
	(SSD1306_Definition_t*) Common_Definition;

  #if SSD1306_Module_DBG >= 5
  printf("\n|SSD1306_Undefine, Name:%.*s>"
	,SSD1306_Definition->common.nameLen
	,SSD1306_Definition->common.name);

  #endif


  // response with error text
	// alloc mem for retMsg
  retMsg = malloc(sizeof(strTextMultiple_t));

  // response with error text
  retMsg->strTextLen = asprintf(&retMsg->strText
	,"SSD1306_Undefine, Name:%.*s"
	,SSD1306_Definition->common.nameLen
	,SSD1306_Definition->common.name);

  return retMsg;

}



/*
 * -------------------  helpers provided to module for type operation ------------------------------
 */



/**
 * -------------------------------------------------------------------------------------------------
 *  FName: SSD1306_ProcessKVInputArgs
 *  Desc: Processes the KEY=VALUE input from Args. Information is pre-parsed to *parsedKVInput
 *  Info: .requiredKV -> Keys that should be there / .forbiddenKV -> Keys that are not allowed
 *  Para: SSD1306_Definition_t *SSD1306_Definition -> Definition that should get the input
 *        parsedKVInputArgs_t *parsedKVInput -> ptr to allocated mem filled with results from parse
 *        uint8_t *argsText -> the ArgsText
 *        size_t argsTextLen -> length of the ArgsText
 *  Rets: Bool -> TRUE = input parsed successful, FALSE = input parsed, but NOT successful, CANCELED
 * -------------------------------------------------------------------------------------------------
 */
bool ICACHE_FLASH_ATTR
SSD1306_ProcessKVInputArgs(SSD1306_Definition_t *SSD1306_Definition
	,parsedKVInputArgs_t *parsedKVInput
	,uint8_t *argsText
	,size_t argsTextLen)
{

// 1. Step: Prepare structures with current values from TYPE & SYSTEM 
//          (to allow an abort if values not complete or in case of processing errors)
/*
  // block #1 get current assigned PWM-Block (low speed / high speed)
  uint8_t newBlock = SSD1306_Definition->Block;

  // block #2 get current assigned PWM Channel
  uint8_t newChannel = SSD1306_Definition->Channel;

  // block #3 get current assigned PWM Timer
  uint8_t newTimer = SSD1306_Definition->Timer;
*/
// ------------------------------------------------------------------------------------------------
  /*
  // we need to process the 'Block' KEY in advance here, because we need this information early

  // Block=High_Speed|Low_Speed
  // -> Setzt den Hardware-PWM-Block des ESP32 (0=HighSpeed / 1= LowSpeed) der verwendet werden soll
  // -> Sets the hardware-PWM-Block of the ESP32 (0=HighSpeed / 1= LowSpeed) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << SSD1306_SET_BLOCK) ) {

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[SSD1306_SET_BLOCK].off
		,parsedKVInput->keyData_t[SSD1306_SET_BLOCK].len, &newBlock, SSD1306_PWM_BLOCK)
		&& (newBlock <= 1) ) {
*/
/*

		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;


		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


*/
/*
		}

	// invalid input detected ?
	else return true;
  }
*/
// ------------------------------------------------------------------------------------------------
  
  // we need to process the 'CHANNEL' KEY in advance here, because we need this information early

  // CHANNEL=[0-7]
  // -> Setzt den Hardware-PWM-Kanal des ESP32 (0-7) der verwendet werden soll
  // -> Sets the hardware-pwm-channel of the ESP32 (0-7) that should be used
/*
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << SSD1306_SET_CHANNEL) ) {

	// valid input happened ?
	if (SCDEH_GetDecUInt8Val((uint8_t*) argsText + parsedKVInput->keyData_t[SSD1306_SET_CHANNEL].off
		,parsedKVInput->keyData_t[SSD1306_SET_CHANNEL].len, &newChannel) 
		&& (newChannel <= 7) ) {
*/
/*

		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;


		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


*/
/*
		}

	// invalid input detected ?
	else return true;
  }
*/
// ------------------------------------------------------------------------------------------------
/*  
  // we need to process the 'TIMER' KEY in advance here, because we need this information early

  // TIMER=[0-3]
  // -> Setzt den Hardware-Timer für den gewählten PWM-Kanal des ESP32 (0-3) der verwendet werden soll
  // -> Sets the hardware-timer for the choosen pwm-channel of the ESP32 (0-3) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << SSD1306_SET_TIMER) ) {

	// valid input happened ?
	if (SCDEH_GetDecUInt8Val((uint8_t*) argsText + parsedKVInput->keyData_t[SSD1306_SET_TIMER].off
		,parsedKVInput->keyData_t[SSD1306_SET_TIMER].len, &newTimer) 
		&& (newTimer <= 3) ) {
*/
/*

		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;


		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


*/
/*
		}

	// invalid input detected ?
	else return true;
  }
*/
// ------------------------------------------------------------------------------------------------
/*
  // block #4 get current assigned / connected GPIO
  uint8_t newGPIO = SSD1306_Definition->GPIO;

  // block #5 reserve for new ATT
  uint32_t newATTVal;

  // block #6 reserve for new AVU
  char newAverageUnit[3];	

  // block #7  get ESP32 PWM channel configuration from selected channel
  // this stores our temp values
  ESP32_PWM_Channel_t newPWM_Channel;
  // pointer to make the hardware counters accessible
  ESP32_PWM_Channel_t *pPWM_Channel =
	(ESP32_PWM_Channel_t*) (0x3FF59000 + (0x14 * newChannel));
  // access low speed channels (instead of high speed channels)?
  if (newBlock) pPWM_Channel =
	(ESP32_PWM_Channel_t*) ( (uint8_t*) pPWM_Channel + 0xa0);
  // move data to temp storage
  memcpy(&newPWM_Channel, pPWM_Channel, sizeof(ESP32_PWM_Channel_t));

  // block #8  get ESP32 PWM timer configuration from selected timer
  // this stores our temp values
  ESP32_PWM_Timer_t newPWM_Timer;
  // pointer to make the hardware timers accessible
  ESP32_PWM_Timer_t *pPWM_Timer =
	(ESP32_PWM_Timer_t*) (0x3FF59140 + (0x08 * newTimer));
  // access low speed timers (instead of high speed timers)?
  if (newBlock) pPWM_Timer =
	(ESP32_PWM_Timer_t*) ( (uint8_t*) pPWM_Timer + 0x20);
  // move data to temp storage
  memcpy(&newPWM_Timer, pPWM_Timer, sizeof(ESP32_PWM_Timer_t));


  // store choosen timer in choosen channel
  newPWM_Channel.TIMER_SEL = newTimer;

// ------------------------------------------------------------------------------------------------

// 2. Step: Process the possible input keys
*/












/*
//>Caps Bit 0---------------------------------------------------------------------------------------

  // on=[ ] -> Setze Kanal an (0-x)
  // on=[ ] -> Set channel on (0-x)

 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_on)

	{

	// new val, save mirror
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax);

	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_on].AffectedReadings;

	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();

	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=on");

	}

//--------------------------------------------------------------------------------------------------

  // off=[ ] -> Setze Kanal aus (0-x)
  // off=[ ] -> Set channel off (0-x)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_off)

	{

	// new val, save mirror
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin);

	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_off].AffectedReadings;

	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();

	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=off");

	}

//>Caps Bit 1---------------------------------------------------------------------------------------

  // max=[ ] -> Setze Kanal maximal (0-x)
  // max=[ ] -> Set channel maximum (0-x) 

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_max)

	{

	// new val, save mirror
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax);

	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_max].AffectedReadings;

	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();

	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=max");

	}

//--------------------------------------------------------------------------------------------------

  // min=[ ] -> Setze Kanal minimal (0-x)
  // min=[ ] -> Set channel minimal (0-x)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_min)

	{

	// New Value = Min
	SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin);

	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_min].AffectedReadings;

	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
		GetUniqueTIST();

	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=min");

	}

//>Caps Bit 2---------------------------------------------------------------------------------------

  // val=[0-9] -> Setze Wert für Kanal (uint8) (0-x)
  // val=[0-9] -> Set value for channel (uint8) (0-x)

 else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_val)
	{

	uint32_t NewVal;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[SwITCH_QF_val].off
		,QueryResultKF->KeyField_Data_t[SwITCH_QF_val].len, &NewVal))

		{

		// val input value clipping
		if (NewVal > SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax)

			{

			NewVal = SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax;

			}

		else if (NewVal < SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin)

			{

			NewVal = SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin;

			}

		// save mirror
		SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
			NewVal);

		// mark affected readings for TX
		AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_val].AffectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=val");

		}

	}

//>Caps Bit 3---------------------------------------------------------------------------------------

  // dim=[0-9] -> Setze dimmer für Kanal (uint8) (0-x)
  // dim=[0-9] -> Set dimming for channel (uint8) (0-x)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_dim)
	{

	uint32_t NewVal;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[SwITCH_QF_dim].off
		,QueryResultKF->KeyField_Data_t[SwITCH_QF_dim].len, &NewVal))
		
		{

		// dim input value clipping
		if (NewVal > 100) NewVal = 100;
		else if (NewVal < 0) NewVal = 0;

		// calculate val from dim
		NewVal = ( (NewVal *
			(SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax - 
			SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin) ) /
			100 );

		// New Value = calculated from input
		SCDE_WriteUInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val,
			NewVal);

		// save mirror
		AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_dim].AffectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].RB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=dim");

		}

	}

//>Caps Bit n.a.------------------------------------------------------------------------------------

  // name=[a-zA-Z0-9_.] -> Setze einen neuen Feature Namen (char[31]) (0-x)
  // name=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_name)

	{

	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[SwITCH_QF_name].off
		,QueryResultKF->KeyField_Data_t[SwITCH_QF_name].len
		,(char*) &SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_Name
		,sizeof (SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_Name)
		,2) )

		{	

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_name].AffectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=name");

		}

	}

//>Caps Bit n.a.------------------------------------------------------------------------------------

  // caps=[ ] -> Fragt nach den Fähigkeiten-Bits (0-x)
  // caps=[ ] -> Request for Capabilities-Bits (0-x)

 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << SwITCH_QF_caps)

	{

	// mark affected readings for TX
	AffectedReadings |= QueryResultKF->KeyField_Data_t[SwITCH_QF_caps].AffectedReadings;

	// New Timestamp
	SysCfgRamNoMirror->MySwITCH_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
		GetUniqueTIST();

	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=on");

	}

*/

/*
  // ATT=[0-9]
  // -> Setze Allzeit-Gesamt-Impulse passend zum aktuellen Zählerstand
  // -> Set alltime-total-tics meeting the currend meter-reading

  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << SSD1306_SET_ATT) ) {

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_att].off
		,QueryResultKF->KeyField_Data_t[S0_QF_att].len, &newATTVal)) {





		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= newATTVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");

		}

	// invalid input detected ?
	else return true;
  }

//>Caps Bit 1,2,3,4,5,6-----------------------------------------------------------------------------

  // AVU=[a-zA-Z0-9_.]
  // -> Setze Einheit für den Durchschnitts-Verbrauchs-Wert (char[3])
  // -> Set unit for average-consumption-value (char[3])

  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << SSD1306_SET_AVU) ) {

	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_avu].off
		,QueryResultKF->KeyField_Data_t[S0_QF_avu].len
		,(char*) &newAverageUnit
		,sizeof (newAverageUnit) // -> case 3 = (Alpha+Num+"³") for Unit Name
		,3) ) {


		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_avu].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=avu");

		}

	// invalid input detected ?
	else return true;
  }

//>Caps Bit 1---------------------------------------------------------------------------------------

  // AVF=[0-9.]
  // -> Setze Durchschnittsverbrauch Berechnungsfaktor (float)
  // -> Set average consumption calculation factor (float)

  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << SSD1306_SET_AVF) ) {

	double NewVal;

	// valid input happened ?
	if (SCDEH_GetFloatVal((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_avf].off
		,QueryResultKF->KeyField_Data_t[S0_QF_avf].len, &NewVal)) {

		// store the value to temp
		//befehl hier!;


		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_avf].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=avf");

		}

	// invalid input detected ?
	else return true;
  }

//--------------------------------------------------------------------------------------------------

  // ATU=[a-zA-Z0-9_.]
  // -> Setze Einheit für den Allzeit-Gesamt-Wert (char[3])
  // -> Set unit for alltime-total-value (char[3])

  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << SSD1306_SET_ATU) ) {

	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_atu].off
		,QueryResultKF->KeyField_Data_t[S0_QF_atu].len
		,(char*) &SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit
		,sizeof (SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit)
		,3) ) // -> case 3 = (Alpha+Num+"³") for Unit Name

		 {

		// store the value to temp
		//befehl hier!;



		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_atu].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=atu");

		}

	// invalid input detected ?
	else return true;
  }

//>Caps Bit 2---------------------------------------------------------------------------------------

  // ATF=[0-9.]
  // -> Setze Umrechnungsfaktor für den Allzeit-Total-Wert (float)
  // -> Set factor for alltime total value (float)

  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << SSD1306_SET_ATF) ) {

	double NewVal;

	// valid input happened ?
	if (SCDEH_GetFloatVal((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_atf].off
		,QueryResultKF->KeyField_Data_t[S0_QF_atf].len, &NewVal)) {

		// store the value to temp
		//befehl hier!;



		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_atf].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=atf");

		}

	// invalid input detected ?
	else return true;
  }


*/














//> ------------------------------------------------------------------------------------------------
/*
  // CH1_LCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << SSD1306_SET_CH1_LCTRL_MODE) ) {

	uint8_t newMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[SSD1306_SET_CH1_LCTRL_MODE].off
		,parsedKVInput->keyData_t[SSD1306_SET_CH1_LCTRL_MODE].len, &newMode, &SSD1306_CTRL_MODE)
		&& (newMode <= 3) ) {

		// store the value to temp
		SSD1306_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = newMode;



		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;


		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


		}

	// invalid input detected ?
	else return true;
  }
*/





















/*

//>Caps Bit 3---------------------------------------------------------------------------------------

  // deb=[0-9] -> Setze debounce Wert, 10-200 recommended (0-x)
  // deb=[0-9] -> Set debounce value, 10-200 recommended (0-x)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_deb)

	{

	uint32_t NewVal;

	// valid input happened ?
	if (SCDEH_GetDecUInt32Val((uint8*)Args+QueryResultKF->KeyField_Data_t[S0_QF_deb].off
		,QueryResultKF->KeyField_Data_t[S0_QF_deb].len, &NewVal))

		{

		// deb input value clipping
		if (NewVal > 1000) NewVal = 1000;
		else if (NewVal < 0) NewVal = 10;

		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Debounce
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_deb].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=deb");

		}

	}


//>Caps Bit n.a.------------------------------------------------------------------------------------

  // name=[a-zA-Z0-9_.] -> Setze einen neuen Feature Namen (char[31]) (0-x)
  // name=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)

  else if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_name)

	{

	// valid input happened ?
	if (SCDEH_GetSpecialStrVal((uint8_t*)Args+QueryResultKF->KeyField_Data_t[S0_QF_name].off
		,QueryResultKF->KeyField_Data_t[S0_QF_name].len
		,(char*) &SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name
		,sizeof (SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name)
		,2) ) // NAME=[a-zA-Z0-9_.] -> Set a new Feature Name (char[31]) (0-x)

		{	

		// SAVE Value
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_name].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=name");

		}

	}

//>Caps Bit n.a.------------------------------------------------------------------------------------

  // caps=[ ] -> Fragt nach den Fähigkeiten-Bits (0-x)
  // caps=[ ] -> Request for Capabilities-Bits (0-x)


 if (QueryResultKF->KeyField_Set == (uint64_t) 1 << S0_QF_caps)
	{

	// mark affected readings for TX
	affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_caps].affectedReadings;

//	// New Timestamp
//	WriteInt32toSysCfgRamRtcMirrored(&SysCfgRamRtcMirrored->MyS0FeatureCfgRamRtcMirrored[ADID].IB01_X_TiSt,
//		GetUniqueTIST());

	// Push processed CMD to to Response ...
	RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=caps");

	}

*/








//> ------------------------------------------------------------------------------------------------
/*
  // CH1_LCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << SSD1306_SET_CH1_LCTRL_MODE) ) {

	uint8_t newMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[SSD1306_SET_CH1_LCTRL_MODE].off
		,parsedKVInput->keyData_t[SSD1306_SET_CH1_LCTRL_MODE].len, &newMode, &SSD1306_CTRL_MODE)
		&& (newMode <= 3) ) {

		// store the value to temp
		SSD1306_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = newMode;



		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;


		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


		}

	// invalid input detected ?
	else return true;
  }
*/
//> ------------------------------------------------------------------------------------------------
/*
  // CH1_HCTRL_MODE=no_modification|invert|inhibit_modification
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << SSD1306_SET_CH1_HCTRL_MODE) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[SSD1306_SET_CH1_HCTRL_MODE].off
		,parsedKVInput->keyData_t[SSD1306_SET_CH1_HCTRL_MODE].len, &NewMode, SSD1306_CTRL_MODE) ) {

		// store ne value
		SSD1306_CNT_CONF_REG.CNT_CH1_LCTRL_MODE = NewMode;


		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


		}

	// invalid input detected ?
	else return true;
  }
*/
//> ------------------------------------------------------------------------------------------------
/*
  // CH1_POS_MODE=no_effect|inc_counter|dec_counter
  // -> ?? Setzt den Hardware-Counter des ESP32 (0-7) der verwendet werden soll
  // -> ?? Sets the hardware counter of the ESP32 (0-7) that should be used
  if (parsedKVInput->keysFoundBF & ( (uint64_t) 1 << SSD1306_SET_CH1_POS_MODE) ) {

	uint8_t NewMode;

	// valid input happened ?
	if (SCDEH_GetQueryKeyID((uint8_t*) argsText + parsedKVInput->keyData_t[SSD1306_SET_CH1_POS_MODE].off
		,parsedKVInput->keyData_t[SSD1306_SET_CH1_POS_MODE].len, &NewMode, SSD1306_CH_MODE) ) {

		// store ne value
		SSD1306_CNT_CONF_REG.CNT_CH1_POS_MODE = NewMode;


		// save new value, from input
		SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].ATTShiftBuf[0]
			= NewVal;

		// save mirror
		SCDE_SaveSysCfgRamFlashMirroredToMirror();

		// mark affected readings for TX
		affectedReadings |= QueryResultKF->KeyField_Data_t[S0_QF_att].affectedReadings;

		// New Timestamp
		SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].IB01_X_TiSt =
			GetUniqueTIST();

		// Push processed CMD to to Response ...
		RespArgsWPos += os_sprintf(RespArgsWPos,"cmd=att");


		}

	// invalid input detected ?
	else return true;
  }
*/







// ------------------------------------------------------------------------------------------------

// 3. Step: Check if the ammount of input elements meets our criteria

  // check if all required Key=Value components are included -> return with FALSE
  if ( (parsedKVInput->keysFoundBF & parsedKVInput->requiredKVBF) != parsedKVInput->requiredKVBF) {

	#if SSD1306_Module_DBG >= 5
	printf("|requiredKVBF, no match!>");	
  	#endif

	return true;
  }

  // check if forbidden Key=Value components are included -> return with FALSE
  if (parsedKVInput->keysFoundBF & parsedKVInput->forbiddenKVBF) {

	#if SSD1306_Module_DBG >= 5
	printf("|forbiddenKVBF, match!>");	
  	#endif

	return true;
  }

// ------------------------------------------------------------------------------------------------

// 4. Step: Passed. Store the new values
/*
  // block #1 store assigned PWM-Block (low speed / high speed)
  if (parsedKVInput->keysFoundBF | ( (1 << SSD1306_SET_BLOCK) ) ) {

	#if SSD1306_Module_DBG >= 5
	printf("|W B#01 PWM_Block=%d>"
		,newBlock);	
  	#endif

	// store assigned PWM-Block
	SSD1306_Definition->Block = newBlock;
  }

  // block #2 store assigned PWM Channel
  if (parsedKVInput->keysFoundBF | ( (1 << SSD1306_SET_CHANNEL) ) ) {

	#if SSD1306_Module_DBG >= 5
	printf("|W B#02 PWM_Channel=%d>"
		,newChannel);	
  	#endif

	// store assigned PWM Channel
	SSD1306_Definition->Channel = newChannel;
  }

  // block #3 store assigned PWM Timer
  if (parsedKVInput->keysFoundBF | ( (1 << SSD1306_SET_TIMER) ) ) {

	#if SSD1306_Module_DBG >= 5
	printf("|W B#03 PWM_Timer=%d>"
		,newTimer);	
  	#endif

	// store assigned PWM Timer
	SSD1306_Definition->Timer = newTimer;
  }

  // block #4 store assigned / connected GPIO
  if (parsedKVInput->keysFoundBF | ( (1 << SSD1306_SET_GPIO) ) ) {

	#if SSD1306_Module_DBG >= 5
	printf("|W B#04 PWM_GPIO=%d>"
		,newGPIO);	
  	#endif

	// store assigned GPIO
	SSD1306_Definition->GPIO = newGPIO;

	PIN_FUNC_SELECT(GPIO_PIN_MUX_REG[newGPIO], PIN_FUNC_GPIO);

	// set GPIO as output
	gpio_set_direction(newGPIO, GPIO_MODE_OUTPUT);

	// configure for high-speed or low-speed ?
	if (newBlock) {

		// setup gpio matrix for low speed
	}

	else {

		// setup gpio matrix for high speed
		gpio_matrix_out(newGPIO, LEDC_HS_SIG_OUT0_IDX + newChannel, 0, 0);
		
	}
  }

  // block #5 store ESP32 pwm configuration registers
  if (parsedKVInput->keysFoundBF & ( (1 << SSD1306_SET_TIMER)
				   | (1 << SSD1306_SET_SIG_OUT_EN)
				   | (1 << SSD1306_SET_IDLE_LV)
				   | (1 << SSD1306_SET_HPOINT)
				   | (1 << SSD1306_SET_DUTY) ) ) {




	// store ESP32 PWM configuration registers
	memcpy(pPWM_Channel, &newPWM_Channel, sizeof(ESP32_PWM_Channel_t));

	# if SSD1306_Module_DBG >= 5
	printf("|ESP32_PWM_Channel_s addr=%p>"
		,pPWM_Channel);

	SCDEFn_at_SSD1306_M->HexDumpOutFn ("dump"
		,pPWM_Channel
		, sizeof(ESP32_PWM_Channel_t) );
	# endif
  }

  // block #6 store ESP32 pwm-timer configuration registers
  if (parsedKVInput->keysFoundBF & ( (1 << SSD1306_SET_TIMER)
				   | (1 << SSD1306_SET_RESOLUTION )
				   | (1 << SSD1306_SET_TICK_SOURCE)
			   	   | (1 << SSD1306_SET_FREQ_HZ) ) ) {

	// reset? It seems that a reset is needed to start timer
	newPWM_Timer.RESET = 0;

	// low speed timer? -> needs 'LOW_SPEED_UPDATE' bit set to take settings
	if (!newBlock) newPWM_Timer.LOW_SPEED_UPDATE = 1;

	// store ESP32 timer configuration registers
	memcpy(pPWM_Timer, &newPWM_Timer, sizeof(ESP32_PWM_Timer_t));

	# if SSD1306_Module_DBG >= 5
	printf("|ESP32_PWM_Timer_s addr=%p>"
		,pPWM_Timer);

	SCDEFn_at_SSD1306_M->HexDumpOutFn ("dump"
		,pPWM_Timer
		, sizeof(ESP32_PWM_Timer_t) );
	# endif
  }
*/
  return false;

}

















/*
//>Add Readings Bit 00 -----------------------------------------------------------------------------

  if (AffectedReadings & SwITCH_R_val)

	{

	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&val=%u",(uint) SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val);

	}

//>Add Readings Bit 01 -----------------------------------------------------------------------------

  if (AffectedReadings & SwITCH_R_dim)

	{

	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&dim=%u",(100 *
		(SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val -
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin) / 
		(SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMax - 
		SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_SwValMin) ) );

	}

//>Add Readings Bit 02 -----------------------------------------------------------------------------

  if (AffectedReadings & SwITCH_R_name)

	{

	// add Unique-Feature-ID for identification purposes (Name-Change, ...)
	RespArgsWPos += SwITCH_UFID(RespArgsWPos, ADID);


	// add capabilities of this feature ...
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&caps=000F");						// 0b1111 <-16BIT-HEX

	// add current name of this feature
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&name=%s",SysCfgRamFlashMirrored->MySwITCH_FeatCfgRamFlashMirrored[ADID].IB01_Name);

	}

//>always add Reading - state ----------------------------------------------------------------------

	// are we adding ?
	if (RespArgsWPos) RespArgsWPos += os_sprintf(RespArgsWPos,"&");

	// always add state ! on / off
	if (SysCfgRamRtcMirrored->MySwITCH_FeatCfgRamRtcMirrored[ADID].RB01_Val == 0)
		RespArgsWPos += os_sprintf(RespArgsWPos, "state=off");

	else  RespArgsWPos += os_sprintf(RespArgsWPos, "state=on");

//--------------------------------------------------------------------------------------------------

*/
















/**
 * ------------------------------------------------------------------------------------------------
 *  FName: SSD1306_SetAffectedReadings
 *  Desc: Do the readings update for this definition according to 'affectedReadings'
 *  Info: 
 *  Para: SSD1306_Definition_t *SSD1306_Definition -> Definition that should get the input
 *        uint64_t affectedReadings -> according to ...
 *  Rets: Bool -> TRUE = input parsed successful, FALSE = input parsed, but NOT successful, CANCELED
 * ------------------------------------------------------------------------------------------------
 */
bool ICACHE_FLASH_ATTR
SSD1306_SetAffectedReadings(SSD1306_Definition_t* SSD1306_Definition
	,uint64_t affectedReadings)
{
/*
 affectedReadings = 0xfffffffffffffff;

  // do we have updates?
  if (affectedReadings) {

  SCDEFn_at_SSD1306_M->readingsBeginUpdateFn((Common_Definition_t*) SSD1306_Definition);

  }

  // we have no updates
  else return false;

// -----------------------------------------------------------------------------------------------

  // temp for reading creation
  uint8_t *readingNameText;
  size_t readingNameTextLen;
  uint8_t *readingValueText;
  size_t readingValueTextLen;

  // pointer to make the hardware counters accessible
  ESP32_PWM_Channel_t *pPWM_Channel =
	(ESP32_PWM_Channel_t*) (0x3FF59000 + (0x14 * SSD1306_Definition->Channel));
  // access low speed channels (instead of high speed channels)?
  if (SSD1306_Definition->Block) pPWM_Channel =
	(ESP32_PWM_Channel_t*) ( (uint8_t*) pPWM_Channel + 0xa0);

  // pointer to make the hardware timers accessible
  ESP32_PWM_Timer_t *pPWM_Timer =
	(ESP32_PWM_Timer_t*) (0x3FF59140 + (0x08 * SSD1306_Definition->Timer));
  // access low speed timers (instead of high speed timers)?
  if (SSD1306_Definition->Block) pPWM_Timer =
	(ESP32_PWM_Timer_t*) ( (uint8_t*) pPWM_Timer + 0x20);

//>Add Readings Bit 00 -----------------------------------------------------------------------------

  // add reading 'Duty'
  if (affectedReadings & SSD1306_R_DUTY) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Duty");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,pPWM_Channel->DUTY);

	SCDEFn_at_SSD1306_M->readingsBulkUpdateFn((Common_Definition_t*) SSD1306_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }

//>Add Readings Bit 01 -----------------------------------------------------------------------------

  // add reading 'Resolution'
  if (affectedReadings & SSD1306_R_RESOLUTION) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Resolution");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,(1 << pPWM_Timer->RESOLUTION) );

	SCDEFn_at_SSD1306_M->readingsBulkUpdateFn((Common_Definition_t*) SSD1306_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);
  }
*/
//>Add Readings Bit 02 -----------------------------------------------------------------------------
/*
  if (affectedReadings & SSD1306_R_AV01_AV05_AV15) {

	int ThisS0CounterCaps = 0b11100000000000000000000000000000;
	// Add readings depending on CAPS ...

	// AV01 = AVerage last 01 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit	
	if (ThisS0CounterCaps & 0b10000000000000000000000000000000)	// AV01 Caps avail?

		{

		RespArgsWPos += os_sprintf(RespArgsWPos // 'AV01' -> AVerage01min (calculated)
			,"&av01=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min - 
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average01Min)*1000) );

		}

	// AV05 = AVerage last 05 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit		
	if (ThisS0CounterCaps & 0b01000000000000000000000000000000)	// AV05 Caps avail?

		{

		RespArgsWPos += os_sprintf(RespArgsWPos	// 'AV05' -> AVerage05min (calculated)
			,"&av05=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min -
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average05Min)*1000) );

		}

	// AV15 = AVerage last 15 Min (calculated), zwingt AVF = AVerageFactor und AVU  = AVerageUnit
	if (ThisS0CounterCaps & 0b00100000000000000000000000000000)	// AV15 Caps avail?

		{

		RespArgsWPos += os_sprintf(RespArgsWPos	// 'AV15' -> AVerage15min (calculated)
			,"&av15=%d.%03d"
			,(int)(SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min)	
			,(int)((SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min -
			 (int)SysCfgRamNoMirror->MyS0_FeatCfgRamNoMirror[ADID].RB01_Average15Min)*1000) );	

		}

	}
*/
//>Add Readings Bit 03 -----------------------------------------------------------------------------
/*
  // add reading 'Average_Factor' //avf'
  if (affectedReadings & SSD1306_R_AVF) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Average_Factor");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%d.%04d"
		,(int) SSD1306_Definition->IB01_AverageFactor	
		,(int) ( (SSD1306_Definition->IB01_AverageFactor -
		(int) SSD1306_Definition->IB01_AverageFactor) * 10000) );

	SCDEFn_at_SSD1306_M->readingsBulkUpdateFn((Common_Definition_t*) SSD1306_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&avf=%d.%04d"
//		,(int)(SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor)	
//		,(int)((SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor -
//		(int)SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageFactor)*10000) );


//>Add Readings Bit 04 -----------------------------------------------------------------------------
/*
  // add reading 'Average_Unit' //avu'
  if (affectedReadings & SSD1306_R_AVU) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Average_Unit");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%s"
		,SSD1306_Definition->IB01_AverageUnit);

	SCDEFn_at_SSD1306_M->readingsBulkUpdateFn((Common_Definition_t*) SSD1306_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }

*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&avu=%s"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AverageUnit);



//>Add Readings Bit 05 -----------------------------------------------------------------------------
/*
  // add reading 'Alltime_Total_Factor' //atf'
  if (affectedReadings & SSD1306_R_ATF) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Alltime_Total_Factor");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%d.%04d"
		,(int) (SSD1306_Definition->IB01_AlltimeTotalFactor)	
		,(int) ( (SSD1306_Definition->IB01_AlltimeTotalFactor -
		(int) SSD1306_Definition->IB01_AlltimeTotalFactor) * 10000) );

	SCDEFn_at_SSD1306_M->readingsBulkUpdateFn((Common_Definition_t*) SSD1306_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&atf=%d.%04d"
//		,(int)(SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor)	
//		,(int)((SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor -
//		(int)SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalFactor)*10000) );


//>Add Readings Bit 06 -----------------------------------------------------------------------------
/*
  // add reading 'Alltime_Total_Unit' //atu'
  if (affectedReadings & SSD1306_R_ATU) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Alltime_Total_Unit");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%s"
		,SSD1306_Definition->IB01_AlltimeTotalUnit);

	SCDEFn_at_SSD1306_M->readingsBulkUpdateFn((Common_Definition_t*) SSD1306_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }
*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&atu=%s"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_AlltimeTotalUnit);


//>Add Readings Bit 07 -----------------------------------------------------------------------------
/*
  // add reading 'Debounce' //deb'
  if (affectedReadings & SSD1306_R_DEB) {

	readingNameTextLen = asprintf((char **) &readingNameText
		,"Debounce");

	readingValueTextLen = asprintf((char **) &readingValueText
		,"%u"
		,SSD1306_Definition->IB01_Debounce);

	SCDEFn_at_SSD1306_M->readingsBulkUpdateFn((Common_Definition_t*) SSD1306_Definition
		,readingNameText
		,readingNameTextLen
		,readingValueText
		,readingValueTextLen);

  }

*/
//	RespArgsWPos += os_sprintf(RespArgsWPos
//		,"&deb=%u"
//		,SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Debounce);


//>Add Readings Bit 08 -----------------------------------------------------------------------------
/*
  if (affectedReadings & SSD1306_R_name)
	{

	// add Unique-Feature-ID for identification purposes (Name-Change, ...)
	RespArgsWPos += S0_UFID(RespArgsWPos, ADID);

	// add capabilities of this feature ...
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&caps=0007");						// 0b11110 <-16BIT-HEX

	// add current name of this feature
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"&name=%s",SysCfgRamFlashMirrored->MyS0_FeatCfgRamFlashMirrored[ADID].IB01_Name);

	}
*/

//>always add Reading - state ----------------------------------------------------------------------
/*
	// are we adding ?
	if (RespArgsWPos) RespArgsWPos += os_sprintf(RespArgsWPos,"&");

	// always add state ! on / off
	RespArgsWPos += os_sprintf(RespArgsWPos,
		"state=on");
*/
//--------------------------------------------------------------------------------------------------


  // all readings done, finnish update
//  SCDEFn_at_SSD1306_M->readingsEndUpdateFn((Common_Definition_t*) SSD1306_Definition);


  return true;
}



























 // xString_t datax;
 // datax.characters = (uint8_t*) cmd;
 // datax.length = 8; //???



void 
task_ssd1306_display_text(ESP32_I2C_Master_Definition_t* ESP32_I2C_Master_Definition, 
	const void *arg_text,
	const size_t arg_text_length)
{
  // for Fn response msg
  strTextMultiple_t *retMsg = NULL;

	// store table of function callbacks provided & made accessible from stage 1 Module
	ESP32_I2C_Master_Fn_t* ESP32_I2C_Master_Fn =
		ESP32_I2C_Master_Definition->ESP32_I2C_Master_Fn;


	char *text = (char*)arg_text;
	uint8_t text_len = arg_text_length;

	i2c_cmd_handle_t cmd;

	uint8_t cur_page = 0;

	cmd = ESP32_I2C_Master_Fn->i2c_cmd_link_createFn();
	ESP32_I2C_Master_Fn->i2c_master_startFn(cmd);
	ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

	ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
	ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, 0x00, true); // reset column
	ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, 0x10, true);
	ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, 0xB0 | cur_page, true); // reset page

	ESP32_I2C_Master_Fn->i2c_master_stopFn(cmd);

	String_t datax;
	datax.p_char = (uint8_t*) cmd;
	datax.len = 8; //???

	retMsg = ESP32_I2C_Master_Definition->common.module->provided->
		WriteFn(ESP32_I2C_Master_Definition, datax);	//10 / portTICK_PERIOD_MS

	for (uint8_t i = 0; i < text_len; i++) {
		if (text[i] == '\n') {
			cmd = ESP32_I2C_Master_Fn->i2c_cmd_link_createFn();
			ESP32_I2C_Master_Fn->i2c_master_startFn(cmd);
			ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

			ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, OLED_CONTROL_BYTE_CMD_STREAM, true);
			ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, 0x00, true); // reset column
			ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, 0x10, true);
			ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, 0xB0 | ++cur_page, true); // increment page

			ESP32_I2C_Master_Fn->i2c_master_stopFn(cmd);

			String_t datax;
			datax.p_char = (uint8_t*) cmd;
			datax.len = 8; //???

			retMsg = ESP32_I2C_Master_Definition->common.module->provided->
				WriteFn(ESP32_I2C_Master_Definition, datax);	//10 / portTICK_PERIOD_MS

		} else {
			cmd = ESP32_I2C_Master_Fn->i2c_cmd_link_createFn();
			ESP32_I2C_Master_Fn->i2c_master_startFn(cmd);
			ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, (OLED_I2C_ADDRESS << 1) | I2C_MASTER_WRITE, true);

			ESP32_I2C_Master_Fn->i2c_master_write_byteFn(cmd, OLED_CONTROL_BYTE_DATA_STREAM, true);
			ESP32_I2C_Master_Fn->i2c_master_writeFn(cmd, font8x8_basic_tr[(uint8_t)text[i]], 8, true);

			ESP32_I2C_Master_Fn->i2c_master_stopFn(cmd);

			String_t datax;
			datax.p_char = (uint8_t*) cmd;
			datax.len = 8; //???

			retMsg = ESP32_I2C_Master_Definition->common.module->provided->
				WriteFn(ESP32_I2C_Master_Definition, datax);	//10 / portTICK_PERIOD_MS
		}
	}

  return;
}













